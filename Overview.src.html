<!DOCTYPE html>
<meta charset=utf-8>
<title>MIME Sniffing Standard</title>
<style>
 @media print { [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase } }
</style>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<link rel=icon href=http://www.whatwg.org/images/icon>



<div class=head>

 <p><a class=logo href=http://www.whatwg.org/><img alt=WHATWG height=101 src=http://www.whatwg.org/images/logo width=101></a></p>
 <h1>MIME Sniffing</h1>
 <h2 class="no-num no-toc">Living Standard &mdash; Last Updated [DATE: 01 Jan 1901]</h2>

 <dl>
  <dt>This Version:
  <dd>
   <a href=http://mimesniff.spec.whatwg.org/>http://mimesniff.spec.whatwg.org/</a>

  <dt>Participate:
  <dd>
   Send feedback to
   <a href="http://www.whatwg.org/mailing-list">whatwg@whatwg.org</a>
   (<a href="http://www.whatwg.org/mailing-list#specs">archives</a>)
   or
   <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=WHATWG&amp;component=MIME">file a bug</a>
   (<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=MIME&amp;resolution=---">open bugs</a>)
  <dd>
   <a href="http://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

  <dt>Version history:
  <dd>
   <a href=https://github.com/whatwg/mimesniff/commits>https://github.com/whatwg/mimesniff/commits</a>
  <dd>
   <a href=https://twitter.com/mimesniff>@mimesniff</a>

  <dt>Editor:
  <dd>
   <a href="http://gphemsley.org/">Gordon P. Hemsley</a> &lt;<a href="mailto:me@gphemsley.org">me@gphemsley.org</a>&gt;

  <dt>Past editors:
  <dd>
   Adam Barth &lt;<a href="mailto:whatwg@adambarth.com">whatwg@adambarth.com</a>&gt; (Google)
  <dd>
   Ian Hickson &lt;<a href="mailto:ian@hixie.ch">ian@hixie.ch</a>&gt; (Google)
 </dl>

 <script src=//dvcs.w3.org/hg/quirks-mode/raw-file/tip/file-bug.js async></script>

 <p class=copyright>
  <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0 Universal</a>.

  To the extent possible under law, the editor has waived all copyright and
  related or neighboring rights to this work.

  In addition, as of [DATE: 01 Jan 1901], the editor has made this
  specification available under the
  <a rel="license" href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0">Open Web Foundation Agreement Version 1.0</a>,
  which is available at
  http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.

</div>



<h2 class="no-num no-toc">Abstract</h2>

<p>
 Many web servers supply incorrect <code>Content-Type</code> header fields
 with their HTTP responses.

 In order to be compatible with these servers, user agents consider the
 content of HTTP responses as well as the <code>Content-Type</code> header
 fields when determining the effective media type of the response.

 This document describes an algorithm for determining the effective media type
 of HTTP responses that balances security and compatibility considerations.



<h2 class=no-num>Table of contents</h2>

<!--toc-->



<h2>Introduction</h2>

<p>
 The HTTP <code>Content-Type</code> header field indicates the media type of
 an HTTP response.

 However, many HTTP servers supply a <code>Content-Type</code> that does not
 match the actual contents of the response.

 Historically, web browsers have tolerated these servers by examining the
 content of HTTP responses in addition to the <code>Content-Type</code> header
 field to determine the effective media type of the response.

<p>
 Without a clear specification of how to "sniff" the media type, each user
 agent has been forced to reverse-engineer the algorithms of other user agents
 in order to maintain interoperability.

 Inevitably, these efforts have not been entirely successful, resulting in
 divergent behaviors among user agents.

 In some cases, these divergent behaviors have had security implications, as a
 user agent could interpret an HTTP response as a different media type than
 the server intended.

<p>
 These security issues are most severe when an "honest" server allows
 potentially malicious users to upload their own files and then serves the
 contents of those files with a low-privilege media type.

 For example, if a server believes that the client will treat a contributed
 file as an image (and thus treat it as benign), but a user agent believes the
 content to be HTML (and thus privileged to execute any scripts contained
 therein), an attacker might be able to steal the user's authentication
 credentials and mount other cross-site scripting attacks.

 (Malicious servers, of course, can specify an arbitrary media type in the
 <code>Content-Type</code> header field.)

 In the absence of media type sniffing, this user-generated content would not
 be interpreted as a high-privilege media type.

<p>
 This document describes a content sniffing algorithm that carefully balances
 the compatibility needs of user agent with the security constraints imposed
 by existing web content.

 The algorithm originated from research conducted by Adam Barth, Juan
 Caballero, and Dawn Song, based on content sniffing algorithms present in
 popular user agents, an extensive database of existing web content, and
 metrics collected from implementations deployed to a sizable number of users.

 <span data-anolis-ref>SECCONTSNIFF</span>

<p>
 Whenever possible, user agents should not employ a content sniffing
 algorithm.

 However, if a user agent does employ a content sniffing algorithm, the user
 agent should use the algorithm in this document; using a different content
 sniffing algorithm could have unexpected security implications.



<h2>Conventions</h2>

<p>
 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
 "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
 document are to be interpreted as described in RFC 2119.

 <span data-anolis-ref>RFC2119</span>

<p>
 Requirements phrased in the imperative as part of algorithms (such as "strip
 any leading space characters" or "return false and abort these steps") are to
 be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY",
 etc.) used in introducing the algorithm.

<p>
 Conformance requirements phrased as algorithms or specific steps can be
 implemented in any manner, so long as the end result is equivalent.

 In particular, note that the algorithms defined in this specification are
 intended to be easy to understand and are not intended to be performant.



<h2>Terminology</h2>

<p>
 A <dfn>byte</dfn> is a <span data-anolis-spec=encoding>byte</span> as defined
 in the Encoding Standard.

 When helpful, a <span>byte</span> will be accompanied by information about
 the ASCII code point it represents.

 <span data-anolis-ref>ENCODING</span>
 <span data-anolis-ref class=informative>ASCII</span>

<p>
 A <dfn>binary data byte</dfn> is a <span>byte</span> in the range 0x00 to
 0x08 (NUL to BS), the <span>byte</span> 0x0B (VT), a <span>byte</span> in the
 range 0x0E to 0x1A (SO to SUB), or a <span>byte</span> in the range 0x1C to
 0x1F (FS to US).

<p>
 A <dfn>whitespace byte</dfn> is any of the following
 <span title=byte>bytes</span>: 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR),
 0x20 (SP).

<p>
 A <dfn>tag-terminating byte</dfn> is any of the following
 <span title=byte>bytes</span>: 0x20 (SP), 0x3E (<code title>&gt;</code>).

<p>
 The <dfn>media type</dfn> of a resource is a technical hint about the use and
 format of that resource.

 <span data-anolis-ref class=informative>MIMETYPE</span>

<p>
 A <dfn>valid media type</dfn> is a
 <span data-anolis-spec=http>media-type</span>, as defined in HTTP/1.1 or its
 successor, and is made up in part by a
 <span data-anolis-spec=http>type</span> and a
 <span data-anolis-spec=http>subtype</span>.

 The <dfn>media type portion</dfn> of a <span>valid media type</span> is the
 string represented by concatenating <span>type</span>, the string
 "<code title>/</code>", and <span>subtype</span>.

 <span data-anolis-ref>HTTP</span>

<p class=note>
 The <span>media type portion</span> of a <span>valid media type</span>
 excludes all <span title=parameter data-anolis-spec=http>parameters</span>
 and is case-insensitive.

 <span data-anolis-ref>HTTP</span>

<p>
 The <dfn>specified media type</dfn> of a resource is the <span>valid media
 type</span> of the resource as determined by the <span>specified media type
 detection algorithm</span>.

<p>
 The <dfn>actual media type</dfn> of a resource is the <span>valid media
 type</span> of the resource as determined by the <span>media type sniffing
 algorithm</span>.

<p>
 A <dfn>scriptable media type</dfn> is any of the following
 <span title="valid media type">valid media types</span>:

 <ul>
  <li>
   <code title>text/html</code>

  <li>
   <code title>text/xml</code>

  <li>
   <code title>application/pdf</code>
 </ul>



<h2>The specified media type</h2>

<p>
 The <span>specified media type</span> of a resource is provided to the user
 agent by an external source associated with that resource.

 The method of obtaining this information varies depending upon how the
 resource is retrieved.

<p>
 The <span>specified media type detection algorithm</span> makes use of the
 <dfn>has-content-type flag</dfn>, which must be unset by default and must
 only be set from within the <span>specified media type detection
 algorithm</span>.

<p>
 To determine the <span>specified media type</span> of a resource, user agents
 must use the following <dfn>specified media type detection algorithm</dfn>:

 <ol>
  <li>
   Let <var>official-type</var> be null.

  <li>
   If the resource is retrieved via HTTP and one or more
   <code>Content-Type</code> headers are associated with the resource, set
   <var>official-type</var> to the value associated with the last such
   <code>Content-Type</code> header and set the <span>has-content-type
   flag</span>.

   <span data-anolis-ref=http>HTTP</span>

   <p class=note>
    File extensions are not used to determine the <span>specified media
    type</span> of a resource retrieved via HTTP because they are unreliable
    and easily spoofed.

  <li>
   If the resource is retrieved directly from the file system, set
   <var>official-type</var> to the <span>media type</span> provided by the
   file system.

  <li>
   If the resource is retrieved via another protocol (such as FTP), set
   <var>official-type</var> to the <span>media type</span> as determined by
   that protocol, if any.

   <span data-anolis-ref class=informative>FTP</span>

  <li>
   If <var>official-type</var> is not a <span>valid media type</span>, set
   <var>official-type</var> to null.

  <li>
   The <span>specified media type</span> is <var>official-type</var>.
 </ol>



<h2>The actual media type</h2>

<p>
 The following flags are used in the <span>media type sniffing
 algorithm</span> and must be unset by default:
 <var class=flag>sniff-all</var>, <var class=flag>sniff-unknown</var>,
 <var class=flag>sniff-text-or-binary</var>,
 <var class=flag>sniff-feed-or-html</var>, <var class=flag>sniff-images</var>,
 <var class=flag>sniff-audio</var>, <var class=flag>sniff-video</var>,
 <var class=flag>sniff-fonts</var>.

 User agents may explicitly set one or more of these flags when calling the
 <span>media type sniffing algorithm</span>.

<p>
 To determine the <span>actual media type</span> of a resource, user agents
 must use the following <dfn>media type sniffing algorithm</dfn>:

 <ol>
  <li>
   If the <span>specified media type</span> is not null and the <span>media
   type portion</span> of the <span>specified media type</span> ends in
   "<code title>+xml</code>" or is equal to "<code title>text/xml</code>" or
   "<code title>application/xml</code>", the <span>actual media type</span> is
   the <span>specified media type</span>.

   Abort these steps.

  <li>
   If the <var class=flag>sniff-all</var> flag is set, set the
   <var class=flag>sniff-unknown</var>,
   <var class=flag>sniff-text-or-binary</var>,
   <var class=flag>sniff-feed-or-html</var>,
   <var class=flag>sniff-images</var>, <var class=flag>sniff-audio</var>,
   <var class=flag>sniff-video</var>, and <var class=flag>sniff-fonts</var>
   flags.

  <li>
   If the <var class=flag>sniff-unknown</var> flag is set or the
   <var class=flag>sniff-text-or-binary</var> flag is set or the
   <var class=flag>sniff-feed-or-html</var> flag is set or the
   <var class=flag>sniff-images</var> flag is set or the
   <var class=flag>sniff-audio</var> flag is set or the
   <var class=flag>sniff-video</var> flag is set or the
   <var class=flag>sniff-fonts</var> flag is set, <dfn>read the resource
   header</dfn> by performing the following steps:

   <ol>
    <li>
     Read <span title=byte>bytes</span> of the resource into <var>buffer</var>
     until one of the following conditions is met:

     <ul>
      <li>
       the end of the resource is reached.

      <li>
       the length of <var>buffer</var> is greater than or equal to 512
       <span title=byte>bytes</span>.

      <li>
       a reasonable amount of time has elapsed, as determined by the user
       agent.
     </ul>

     <p class=note>
      If the length of <var>buffer</var> is greater than or equal to 512
      <span title=byte>bytes</span>, the <span>media type sniffing
      algorithm</span> will be deterministic for the majority of cases.

      However, certain factors (such as a slow connection) may prevent the
      user agent from reading 512 <span title=byte>bytes</span> in a
      reasonable amount of time.

     <li>
      The <dfn>resource header</dfn> is <var>buffer</var>.
   </ol>

   <p class=note>
    This step is always performed if any sniffing is allowed.

  <li>
   If the <var class=flag>sniff-unknown</var> flag is set and the
   <span>specified media type</span> is null or if the
   <var class=flag>sniff-unknown</var> flag is set and the <span>specified
   media type</span> is not null and the <span>media type portion</span> of
   the <span>specified media type</span> is equal to
   "<code title>unknown/unknown</code>",
   "<code title>application/unknown</code>", or "<code title>*/*</code>",
   execute the <span>rules for identifying an unknown media type</span>.

  <li>
   If the <var class=flag>sniff-text-or-binary</var> flag is set and the
   <span>has-content-type flag</span> is set and the <span>specified media
   type</span> is <strong>exactly</strong> equal to one of the values in the
   following table, execute the <span>rules for distinguishing if a resource
   is text or binary</span>:

   <table>
    <thead>
     <tr>
      <th>Bytes in Hexadecimal</th>
      <th>Bytes in ASCII</th>
     </tr>
    <tbody>
     <tr>
      <td>
       74 65 78 74 2F 70 6C 61 69 6E
      </td>
      <td>
       <code title>text/plain</code>
      </td>
     </tr>
     <tr>
      <td>
       74 65 78 74 2F 70 6C 61 69 6E<br>
       3B 20 63 68 61 72 73 65 74 3D<br>
       49 53 4F 2D 38 38 35 39 2D 31
      </td>
      <td>
       <code title>text/plain; charset=ISO-8859-1</code>
      </td>
     </tr>
     <tr>
      <td>
       74 65 78 74 2F 70 6C 61 69 6E<br>
       3B 20 63 68 61 72 73 65 74 3D<br>
       69 73 6F 2D 38 38 35 39 2D 31
      </td>
      <td>
       <code title>text/plain; charset=iso-8859-1</code>
      </td>
     </tr>
     <tr>
      <td>
       74 65 78 74 2F 70 6C 61 69 6E<br>
       3B 20 63 68 61 72 73 65 74 3D<br>
       55 54 46 2D 38
      </td>
      <td>
       <code title>text/plain; charset=UTF-8</code>
      </td>
     </tr>
   </table>

   <p class=note>
    The <span>media type sniffing algorithm</span> detects these exact
    <span>byte</span> sequences because some older installations of Apache
    contain a bug that causes them to supply one of these Content-Type headers
    when serving files with unrecognized file extensions.

  <li>
   <!-- XXX: Why are we checking to see if the image type is supported by the
             user agent if we're just going to sniff it again anyway? -->
   If the <var class=flag>sniff-images</var> flag is set and the
   <span>specified media type</span> is <span>an image type supported by the
   user agent</span>, execute the <span>rules for sniffing images
   specifically</span>.

  <li>
   <!-- XXX: Why are we checking to see if the audio type is supported by the
             user agent if we're just going to sniff it again anyway? -->
   If the <var class=flag>sniff-audio</var> flag is set and the
   <span>specified media type</span> is <span>an audio type supported by the
   user agent</span>, execute the <span>rules for sniffing audio
   specifically</span>.

  <li>
   <!-- XXX: Why are we checking to see if the video type is supported by the
             user agent if we're just going to sniff it again anyway? -->
   If the <var class=flag>sniff-video</var> flag is set and the
   <span>specified media type</span> is <span>a video type supported by the
   user agent</span>, execute the <span>rules for sniffing videos
   specifically</span>.

  <li>
   <!-- XXX: Why are we checking to see if the font type is supported by the
             user agent if we're just going to sniff it again anyway? -->
   If the <var class=flag>sniff-fonts</var> flag is set and the
   <span>specified media type</span> is <span>a font type supported by the
   user agent</span>, execute the <span>rules for sniffing fonts
   specifically</span>.

  <li>
   If the <var class=flag>sniff-feed-or-html</var> flag is set and the
   <span>specified media type</span> is not null and the <span>media type
   portion</span> of the <span>specified media type</span> is equal to
   "<code title>text/html</code>", execute the <span>rules for distinguishing
   if a resource is a feed or HTML</span>.

  <li>
   The <span>actual media type</span> is the <span>specified media
   type</span>.
 </ol>



<h3>Text or binary</h3>

<p>
 This section defines the <dfn id=rules-for-text-or-binary>rules for
 distinguishing if a resource is text or binary</dfn>:

<ol>
 <li>
  Let <var>length</var> be the number of <span title=byte>bytes</span> in the
  <span>resource header</span>.

 <li>
  If <var>length</var> is greater than or equal to 2 and the first 2 bytes of
  the <span>resource header</span> are equal to 0xFE 0xFF (UTF-16BE BOM) or
  0xFF 0xFE (UTF-16LE BOM), the <span>actual media type</span> is
  "<code title>text/plain</code>".

  Abort these steps.

 <li>
  If <var>length</var> is greater than or equal to 3 and the first 3 bytes of
  the <span>resource header</span> are equal to 0xEF 0xBB 0xBF (UTF-8 BOM),
  the <span>actual media type</span> is "<code title>text/plain</code>".

  Abort these steps.

 <li>
  If the <span>resource header</span> contains no
  <span title="binary data byte">binary data bytes</span>, the <span>actual
  media type</span> is "<code title>text/plain</code>".

  Abort these steps.

 <li>
  Execute the <span>rules for identifying an unknown media type</span> with
  the <var>sniff-scriptable</var> flag unset.

  <p class=warning>
   It is critical that the <span>rules for distinguishing if a resource is
   text or binary</span> never determine the <span>actual media type</span> to
   be a <span>scriptable media type</span>, as this could allow a privilege
   escalation attack.
</ol>



<h3>Unknown Type</h3>

<ol>
 <li>
  The user agent MAY wait for 512 or more bytes to arrive for the same reason
  as in the "text or binary" section above.

 <li>
  Let <var>n</var> be the smaller of either 512 or the number of bytes that
  have already arrived.

 <li>
  For each row in the table below:

  <dl class=switch>
   <dt>If the row has no "WS" bytes (see <a href=#ws-note>Note</a>):
   <dd>
    <ol>
     <li>
      Let <var>pattern-length</var> be the length of the pattern.

     <li>
      If <var>n</var> is smaller than <var>pattern-length</var> then skip this
      row.

     <li>
      Apply the bit-wise "and" operator to the first <var>pattern-length</var>
      bytes and the given mask, and let the result be the
      <var>masked-data</var>.

     <li>
      If the bytes of the <var>masked-data</var> match the given pattern bytes
      exactly, then let the <var>sniffed-type</var> be the type given in the
      cell of the third column in that row and abort these steps.
    </ol>

   <dt>If the row has a "WS" byte or a "_>" byte (see <a href=#sb-note>Note</a>):
   <dd>
    <ol>
     <li>
      Let <var>index-pattern</var> be an index into the mask and pattern byte
      strings of the row.

     <li>
      Let <var>index-stream</var> be an index into the byte stream being
      examined.

     <li>
      <var>LOOP</var>:
      If <var>index-stream</var> points beyond the end of the byte stream,
      then this row doesn't match and skip this row.

     <li>
      Examine the <var>index-stream</var>-th byte of the byte stream as
      follows:

      <dl class=switch>
       <dt>If the <var>index-pattern</var>-th byte of the pattern is a normal hexadecimal byte and neither a "WS" byte nor a "_>" byte:
       <dd>
        <ol>
         <li>
          If the bit-wise "and" operator, applied to the
          <var>index-stream</var>-th byte of the stream and the
          <var>index-pattern</var>-th byte of the mask, yield a value
          different than the <var>index-pattern</var>-th byte of the pattern,
          then skip this row.

         <li>
          Otherwise, increment <var>index-pattern</var> to the next byte in
          the mask and pattern and <var>index-stream</var> to the next byte
          in the byte stream.
        </ol>

       <dt>Otherwise, if the <var>index-pattern</var>-th byte of the pattern is a "WS" byte:
       <dd>
        <p class=note id=ws-note>
         "WS" means "whitespace", and allows insignificant whitespace to be
         skipped when sniffing for a type signature.

        <ol>
         <li>
          If the <var>index-stream</var>-th byte of the stream is one of 0x09
          (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or
          0x20 (ASCII space), then increment only the <var>index-stream</var>
          to the next byte in the byte stream.

         <li>
          Otherwise, increment only the <var>index-pattern</var> to the next
          byte in the mask and pattern.
        </ol>

       <dt>Otherwise, if the <var>index-pattern</var>-th byte of the pattern is a "_>" byte:
       <dd>
        <p class=note id=sb-note>
         "_>" means "space-or-bracket", and allows HTML tag names to terminate
         with either a space or a greater than sign.

        <ol>
         <li>
          If <var>index-stream</var>-th byte of the stream is different than
          0x20 (ASCII space) or 0x3E (ASCII ">"), then skip this row.

         <li>
          Otherwise, increment <var>index-pattern</var> to the next byte in
          the mask and pattern and <var>index-stream</var> to the next byte
          in the byte stream.
        </ol>
      </dl>

     <li>
      If <var>index-pattern</var> does not point beyond the end of the mask
      and pattern byte strings, then jump back to the <var>LOOP</var> step in
      this algorithm.

     <li>
      Otherwise, let the <var>sniffed-type</var> be the type given in the cell
      of the third column in that row and abort these steps.
    </ol>
  </dl>

 <li>
  If the first n bytes match <a href=#signature-for-mp4>the signature for
  MP4</a>, then let the <var>sniffed-type</var> be video/mp4 and abort these
  steps.

 <li>
  If none of the first n bytes are binary data (as defined in the "text or
  binary" section), then let the <var>sniffed-type</var> be "text/plain" and
  abort these steps.

 <li>
  Otherwise, let the <var>sniffed-type</var> be "application/octet-stream" and
  abort these steps.
</ol>

<p>
 The table used by the above algorithm is:

 <table>
  <thead>
   <tr>
    <th>Mask in Hex</th>
    <th>Pattern in Hex</th>
    <th>Sniffed Type</th>
    <th>Security</th>
    <th>Comment</th>
   </tr>
  <tbody>
   <tr>
    <td>
     FF FF FF DF
     DF DF DF DF
     DF DF FF DF
     DF DF DF FF
    </td>
    <td>
     WS 3C 21 44
     4F 43 54 59
     50 45 20 48
     54 4D 4C _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;!DOCTYPE HTML</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF FF
    </td>
    <td>
     WS 3C 48 54
     4D 4C _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;HTML</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF FF
    </td>
    <td>
     WS 3C 48 45
     41 44 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;HEAD</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF DF DF
     FF
    </td>
    <td>
     WS 3C 53 43
     52 49 50 54
     _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;SCRIPT</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF DF DF
     FF
    </td>
    <td>
     WS 3C 49 46
     52 41 4d 45
     _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;IFRAME</td>
   </tr>
   <tr>
    <td>
     FF FF DF FF
     FF
    </td>
    <td>
     WS 3C 48 31
     _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;H1</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF FF
    </td>
    <td>
     WS 3C 44 49
     56 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;DIV</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF FF
    </td>
    <td>
     WS 3C 46 4f
     4e 54 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;FONT</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF DF FF
    </td>
    <td>
     WS 3C 54 41
     42 4c 45 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;TABLE</td>
   </tr>
   <tr>
    <td>
     FF FF DF FF
    </td>
    <td>
     WS 3C 41 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;A</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF DF FF
    </td>
    <td>
     WS 3C 53 54
     59 4c 45 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;STYLE</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF DF FF
    </td>
    <td>
     WS 3C 54 49
     54 4c 45 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;TITLE</td>
   </tr>
   <tr>
    <td>
     FF FF DF FF
    </td>
    <td>
     WS 3C 42 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;B</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     DF DF FF
    </td>
    <td>
     WS 3C 42 4f
     44 59 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;BODY</td>
   </tr>
   <tr>
    <td>
     FF FF DF DF
     FF
    </td>
    <td>
     WS 3C 42 52
     _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;BR</td>
   </tr>
   <tr>
    <td>
     FF FF DF FF
    </td>
    <td>
     WS 3C 50 _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;P</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF
    </td>
    <td>
     WS 3C 21 2d
     2d _>
    </td>
    <td>text/html</td>
    <td>Scriptable</td>
    <td>&lt;!--</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF
    </td>
    <td>
     WS 3C 3f 78
     6d 6c
    </td>
    <td>text/xml</td>
    <td>Scriptable</td>
    <td>&lt;?xml (Note the case sensitivity [mask = FF instead of DF] and lack of trailing _>)</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF
    </td>
    <td>
     25 50 44 46
     2D
    </td>
    <td>application/pdf</td>
    <td>Scriptable</td>
    <td>The string "%PDF-", the PDF signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF FF FF
     FF FF FF
    </td>
    <td>
     25 21 50 53
     2D 41 64 6F
     62 65 2D
    </td>
    <td>application/postscript</td>
    <td>Safe</td>
    <td>The string "%!PS-Adobe-", the PostScript signature.</td>
   </tr>
   <tr>
    <td>
     FF FF 00 00
    </td>
    <td>
     FE FF 00 00
    </td>
    <td>text/plain</td>
    <td>n/a</td>
    <td>UTF-16BE BOM</td>
   </tr>
   <tr>
    <td>
     FF FF 00 00
    </td>
    <td>
     FF FE 00 00
    </td>
    <td>text/plain</td>
    <td>n/a</td>
    <td>UTF-16LE BOM</td>
   </tr>
   <tr>
    <td>
     FF FF FF 00
    </td>
    <td>
     EF BB BF 00
    </td>
    <td>text/plain</td>
    <td>n/a</td>
    <td>UTF-8 BOM</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF
    </td>
    <td>
     47 49 46 38
     37 61
    </td>
    <td>image/gif</td>
    <td>Safe</td>
    <td>The string "GIF87a", a GIF signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF
    </td>
    <td>
     47 49 46 38
     39 61
    </td>
    <td>image/gif</td>
    <td>Safe</td>
    <td>The string "GIF89a", a GIF signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF FF FF
    </td>
    <td>
     89 50 4E 47
     0D 0A 1A 0A
    </td>
    <td>image/png</td>
    <td>Safe</td>
    <td>The PNG signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF
    </td>
    <td>
     FF D8 FF
    </td>
    <td>image/jpeg</td>
    <td>Safe</td>
    <td>A JPEG SOI marker followed by a byte of another marker.</td>
   </tr>
   <tr>
    <td>
     FF FF
    </td>
    <td>
     42 4D
    </td>
    <td>image/bmp</td>
    <td>Safe</td>
    <td>The string "BM", a BMP signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     00 00 00 00
     FF FF FF FF
     FF FF
    </td>
    <td>
     52 49 46 46
     00 00 00 00
     57 45 42 50
     56 50
    </td>
    <td>image/webp</td>
    <td>Safe</td>
    <td>"RIFF" followed by four bytes, followed by "WEBPVP".</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
    </td>
    <td>
     00 00 01 00
    </td>
    <td>image/vnd.microsoft.icon</td>
    <td>Safe</td>
    <td>A Windows Icon signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF
    </td>
    <td>
     4F 67 67 53
     00
    </td>
    <td>application/ogg</td>
    <td>Safe</td>
    <td>An Ogg audio or video signature.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     00 00 00 00
     FF FF FF FF
    </td>
    <td>
     52 49 46 46
     00 00 00 00
     57 41 56 45
    </td>
    <td>audio/wave</td>
    <td>Safe</td>
    <td>"RIFF" followed by four bytes, followed by "WAVE".</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
    </td>
    <td>
     1A 45 DF A3
    </td>
    <td>video/webm</td>
    <td>Safe</td>
    <td>The WebM signature [TODO: Use more bytes?]</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
     FF FF FF
    </td>
    <td>
     52 61 72 20
     1A 07 00
    </td>
    <td>application/x-rar-compressed</td>
    <td>Safe</td>
    <td>A RAR archive.</td>
   </tr>
   <tr>
    <td>
     FF FF FF FF
    </td>
    <td>
     50 4B 03 04
    </td>
    <td>application/zip</td>
    <td>Safe</td>
    <td>A ZIP archive.</td>
   </tr>
   <tr>
    <td>
     FF FF FF
    </td>
    <td>
     1F 8B 08
    </td>
    <td>application/x-gzip</td>
    <td>Safe</td>
    <td>A GZIP archive.</td>
   </tr>
 </table>

<p class=XXX>MP3 audio.</p>

<p>
 user agents MAY support additional types if necessary, by implicitly adding
 to the above table.

 However, user agents SHOULD NOT not use any other patterns for types already
 mentioned in the table above because this could then be used for privilege
 escalation (where, e.g., a server uses the above table to determine that
 content is not HTML and thus safe from cross-site scripting attacks, but then
 a user agent detects it as HTML anyway and allows script to execute).

 In extending this table, user agents SHOULD NOT introduce any privilege
 escalation vulnerabilities.

<p class=note>
 The column marked "security" is used by the algorithm in the "text or binary"
 section, to avoid sniffing text/plain content as a type that can be used for
 a privilege escalation attack.


<h4>Signature for MP4</h4>

<p>
 This section defines whether a sequence of <var>n</var> bytes
 <dfn id=matches-the-signature-for-mp4>match the signature for MP4</dfn>.

<ol>
 <li>
  If <var>n</var> is less than 12, then return that the sequence does not
  match the signature for MP4 and abort these steps.

 <li>
  Let <var>box-size</var> be the value of the first four bytes, interpreted as
  a 32 bit unsigned, big-endian integer.

 <li>
  If <var>n</var> is less than <var>box-size</var> or if <var>box-size</var>
  is not evenly divisible by 4, then return that the sequence does not match
  the signature for MP4 and abort these steps.

 <li>
  If bytes 4 through 7 (inclusive, zero-based) of the sequence are not the
  sequence 0x66 0x74 0x79 0x70 (the ASCII string "ftyp"), then return that the
  sequence does not match the signature for MP4 and abort these steps.

 <li>
  For each <var>i</var> from 2 to <code><var>box-size</var>/4 - 1</code>
  (inclusive):

  <ol>
   <li>
    If <var>i</var> is equal to 3, continue to the next <var>i</var>, if any.

    (These bytes correspond to the minor version number.)

   <li>
    If bytes <code>4*i</code> through <code>4*i + 2</code> (inclusive,
    zero-based) of the sequence are the sequence 0x6D 0x70 0x34 (the ASCII
    string "mp4"), then return that the sequence <strong>does</strong> match
    the signature for MP4 and abort these steps.
  </ol>

 <li>
  Return that the sequence does not match the signature for MP4.
</ol>


<h3>Images</h3>

<p>
 This section defines the <dfn id=rules-for-sniffing-images-specifically>rules
 for sniffing images specifically</dfn>.

<ol>
 <li>
  If the <var>official-type</var> is "image/svg+xml", then let the
  <var>sniffed-type</var> be the <var>official-type</var> (an XML type) and
  abort these steps.

 <li>
  <!-- XXX the <a> needs to be a <span> linking to a <dfn> -->
  If the first bytes match one of the signatures in
  <a href="#unknown-type">unknown type</a> for one of the following media
  types, then let the <var>sniffed-type</var> be the corresponding media type
  and abort these steps:

  <ul>
   <li>
    image/gif

   <li>
    image/png

   <li>
    image/jpeg

   <li>
    image/bmp

   <li>
    image/vnd.microsoft.icon

   <li>
    image/webp
  </ul>

 <li>
  Otherwise, let the <var>sniffed-type</var> be the official-type and abort
  these steps.
</ol>


<h3>Video</h3>

<p>
 This section defines the <dfn id=rules-for-sniffing-video-specifically>rules
 for sniffing videos specifically</dfn>.

<ol>
 <li>
  <!-- XXX the <a> needs to be a <span> linking to a <dfn> -->
  If the first bytes match one of the signatures in
  <a href="#unknown-type">unknown type</a> for one of the following media
  types, then let the <var>sniffed-type</var> be the corresponding media type
  and abort these steps:

  <ul>
   <li>
    video/mp4

   <li>
    video/webm

   <li>
    application/ogg
  </ul>

 <li>
  Otherwise, let the <var>sniffed-type</var> be the <var>official-type</var>
  and abort these steps.
</ol>


<h3>Fonts</h3>

<p>
 This section defines the <dfn id=rules-for-sniffing-fonts-specifically>rules
 for sniffing fonts specifically</dfn>.

<p class=XXX>TODO</p>

<p>
 Otherwise, let the <var>sniffed-type</var> be the <var>official-type</var>
 and abort these steps.


<h3>Feed or HTML</h3>

<ol>
 <li>
  The user agent MAY wait for 512 or more bytes to arrive for the same reason
  as in the "text or binary" section above.

 <li>
  Let <var>s</var> be the stream of bytes, and let <var>s</var>[<var>i</var>]
  represent the byte in <var>s</var> with position <var>i</var>, treating
  <var>s</var> as zero-indexed (so the first byte is at <var>i</var>=0).

 <li>
  If at any point this algorithm requires the user agent to determine the
  value of a byte in <var>s</var> which has not yet arrived, or which is past
  the first 512 bytes, or which is beyond the end of the byte stream, the
  algorithm stops and the <var>sniffed-type</var> is "text/html".

  <p class=note>
   User agents are allowed, by the first step of this algorithm, to wait until
   the first 512 bytes have arrived.

 <li>
  Initialize <var>pos</var> to 0.

 <li>
  If <var>s</var>[0] equals 0xEF, <var>s</var>[1] equals 0xBB, and
  <var>s</var>[2] equals 0xBF, then set <var>pos</var> to 3.

  (This skips over a leading UTF-8 BOM, if any.)

 <li>
  <var>LOOP</var>:
  Examine <var>s</var>[<var>pos</var>].

  <dl class=switch>
   <dt>If it equals 0x09 (ASCII tab), 0x20 (ASCII space), 0x0A (ASCII LF), or 0x0D (ASCII CR):
   <dd>
    Increase <var>pos</var> by 1 and repeat this step.

   <dt>If it equals 0x3C (ASCII "&lt;"):
   <dd>
    Increase <var>pos</var> by 1 and go to the next step.

   <dt>If it is anything else:
   <dd>
    Let the <var>sniffed-type</var> be "text/html" and abort these steps.
  </dl>

 <li>
  If the bytes with positions <var>pos</var> to <var>pos</var>+2 in
  <var>s</var> are exactly equal to 0x21, 0x2D, 0x2D respectively (ASCII for
  "!--"), then:

  <ol>
   <li>
    Increase <var>pos</var> by 3.

   <li>
    If the bytes with positions <var>pos</var> to <var>pos</var>+2 in
    <var>s</var> are exactly equal to 0x2D, 0x2D, 0x3E respectively (ASCII for
    "--&gt;"), then increase <var>pos</var> by 3 and jump back to the previous
    step (the step labeled <var>LOOP</var>) in the overall algorithm in this
    section.

   <li>
    Otherwise, increase <var>pos</var> by 1.

   <li>
    Return to step 2 in these substeps.
  </ol>

 <li>
  If <var>s</var>[<var>pos</var>] equals 0x21 (ASCII "!"):

  <ol>
   <li>
    Increase <var>pos</var> by 1.

   <li>
    If <var>s</var>[<var>pos</var>] equals 0x3E, then increase <var>pos</var>
    by 1 and jump back to the step labeled <var>LOOP</var> in the overall
    algorithm in this section.

   <li>
    Otherwise, return to step 1 in these substeps.
  </ol>

 <li>
  If <var>s</var>[<var>pos</var>] equals 0x3F (ASCII "?"):

  <ol>
   <li>
    Increase <var>pos</var> by 1.

   <li>
    If <var>s</var>[<var>pos</var>] and <var>s</var>[<var>pos</var>+1] equal
    0x3F and 0x3E respectively, then increase <var>pos</var> by 1 and jump
    back to the step labeled <var>LOOP</var> in the overall algorithm in this
    section.

   <li>
    Otherwise, return to step 1 in these substeps.
  </ol>

 <li>
  Otherwise, if the bytes in <var>s</var> starting at <var>pos</var> match any
  of the sequences of bytes in the first column of the following table, then
  the user agent MUST follow the steps given in the corresponding cell in the
  second column of the same row.

  <table>
   <thead>
    <tr>
     <th>Bytes in Hexadecimal</th>
     <th>Requirement</th>
     <th>Comment</th>
    </tr>
   <tbody>
    <tr>
     <td>72 73 73</td>
     <td>Let the <var>sniffed-type</var> be "application/rss+xml" and abort these steps.</td>
     <td>rss</td>
    </tr>
    <tr>
     <td>66 65 65 64</td>
     <td>Let the <var>sniffed-type</var> be "application/atom+xml" and abort these steps.</td>
     <td>feed</td>
    </tr>
    <tr>
     <td>72 64 66 3A 52 44 46</td>
     <td>Continue to the next step in this algorithm.</td>
     <td>rdf:RDF</td>
    </tr>
  </table>

  <p>
   If none of the byte sequences above match the bytes in <var>s</var>
   starting at <var>pos</var>, then let the <var>sniffed-type</var> be
   "text/html" and abort these steps.

 <li>
  Initialize <var>RDF-flag</var> to 0.

 <li>
  Initialize <var>RSS-flag</var> to 0.

 <li>
  If the bytes with positions <var>pos</var> to <var>pos</var>+23 in
  <var>s</var> are exactly equal to 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
  0x70, 0x75, 0x72, 0x6C, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 0x72, 0x73, 0x73,
  0x2F, 0x31, 0x2E, 0x30, 0x2F respectively (ASCII for
  "http://purl.org/rss/1.0/"), then:

  <ol>
   <li>
    Increase <var>pos</var> by 23.

   <li>
    Set <var>RSS-flag</var> to 1.
  </ol>

 <li>
  If the bytes with positions <var>pos</var> to <var>pos</var>+42 in
  <var>s</var> are exactly equal to 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
  0x77, 0x77, 0x77, 0x2E, 0x77, 0x33, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 0x31,
  0x39, 0x39, 0x39, 0x2F, 0x30, 0x32, 0x2F, 0x32, 0x32, 0x2D, 0x72, 0x64,
  0x66, 0x2D, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x2D, 0x6E, 0x73, 0x23
  respectively (ASCII for "http://www.w3.org/1999/02/22-rdf-syntax-ns#"),
  then:

  <ol>
   <li>
    Increase pos by 42.

   <li>
    Set <var>RDF-flag</var> to 1.
  </ol>

 <li>
  Increase <var>pos</var> by 1.

 <li>
  If both the <var>RDF-flag</var> and the <var>RSS-flag</var> are 1, then let
  the <var>sniffed-type</var> be "application/rss+xml" and abort these steps.

 <li>
  If <var>pos</var> points beyond the end of the byte stream <var>s</var>,
  then continue to step 19 of this algorithm.

 <li>
  Jump back to step 13 of this algorithm.

 <li>
  Let the <var>sniffed-type</var> be "text/html" and abort these steps.
</ol>

<p>
 For efficiency reasons, implementations might wish to implement this
 algorithm and the algorithm for detecting the character encoding of HTML
 documents in parallel.



<h2 class=no-num>References</h2>

<div id=anolis-references></div>



<h2 class=no-num>Acknowledgements</h2>

<p>Thanks to
Alfred Hönes,
Anne van Kesteren,
Boris Zbarsky,
David Singer,
Mark Pilgrim,
and
Russ Cox.

<script id=head src=//www.whatwg.org/specs/web-apps/current-work/dfn.js></script>
